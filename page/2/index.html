<!DOCTYPE html>



  


<html class="theme-next mist use-motion" lang="en">
<head>
  <meta charset="UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=edge" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"/>
<meta name="theme-color" content="#222">









<meta http-equiv="Cache-Control" content="no-transform" />
<meta http-equiv="Cache-Control" content="no-siteapp" />
















  
  
  <link href="/lib/fancybox/source/jquery.fancybox.css?v=2.1.5" rel="stylesheet" type="text/css" />







<link href="/lib/font-awesome/css/font-awesome.min.css?v=4.6.2" rel="stylesheet" type="text/css" />

<link href="/css/main.css?v=5.1.4" rel="stylesheet" type="text/css" />


  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png?v=5.1.4">


  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png?v=5.1.4">


  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png?v=5.1.4">


  <link rel="mask-icon" href="/images/logo.svg?v=5.1.4" color="#222">





  <meta name="keywords" content="Hexo, NexT" />










<meta property="og:type" content="website">
<meta property="og:title" content="Hexo">
<meta property="og:url" content="http://example.com/page/2/index.html">
<meta property="og:site_name" content="Hexo">
<meta property="og:locale" content="en_US">
<meta property="article:author" content="John Doe">
<meta name="twitter:card" content="summary">



<script type="text/javascript" id="hexo.configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '',
    scheme: 'Mist',
    version: '5.1.4',
    sidebar: {"position":"left","display":"post","offset":12,"b2t":false,"scrollpercent":false,"onmobile":false},
    fancybox: true,
    tabs: true,
    motion: {"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},
    duoshuo: {
      userId: '0',
      author: 'Author'
    },
    algolia: {
      applicationID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    }
  };
</script>



  <link rel="canonical" href="http://example.com/page/2/"/>





  <title>Hexo</title>
  








<meta name="generator" content="Hexo 6.3.0"></head>

<body itemscope itemtype="http://schema.org/WebPage" lang="en">

  
  
    
  

  <div class="container sidebar-position-left 
  page-home">
    <div class="headband"></div>

    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-wrapper">
  <div class="site-meta ">
    

    <div class="custom-logo-site-title">
      <a href="/"  class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">Hexo</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
      
        <p class="site-subtitle"></p>
      
  </div>

  <div class="site-nav-toggle">
    <button>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
    </button>
  </div>
</div>

<nav class="site-nav">
  

  
    <ul id="menu" class="menu">
      
        
        <li class="menu-item menu-item-home">
          <a href="/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-home"></i> <br />
            
            Home
          </a>
        </li>
      
        
        <li class="menu-item menu-item-tags">
          <a href="/tags/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-tags"></i> <br />
            
            Tags
          </a>
        </li>
      
        
        <li class="menu-item menu-item-archives">
          <a href="/archives/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-archive"></i> <br />
            
            Archives
          </a>
        </li>
      

      
    </ul>
  

  
</nav>



 </div>
    </header>

    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          <div id="content" class="content">
            
  <section id="posts" class="posts-expand">
    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://example.com/2023/03/28/ORBSLAM3_NOTE_3/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Hexo">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2023/03/28/ORBSLAM3_NOTE_3/" itemprop="url">ORB-SLAM3源码阅读:Tracking</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2023-03-28T16:45:51+08:00">
                2023-03-28
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="orbslam3学习笔记3"><a class="markdownIt-Anchor" href="#orbslam3学习笔记3"></a> ORBSLAM3学习笔记(3)</h1>
<p>这篇博客主要是对Tracking.cc文件的学习。</p>
<hr />
<h2 id="源码阅读"><a class="markdownIt-Anchor" href="#源码阅读"></a> 源码阅读</h2>
<h3 id="trackingtracking"><a class="markdownIt-Anchor" href="#trackingtracking"></a> Tracking::Tracking()</h3>
<p>构造函数首先从配置文件中加载相机参数</p>
<pre><code>newParameterLoader(settings);
</code></pre>
<p>我们马上具体看这个函数是如何实现的：</p>
<p><strong>1. 读取相机1</strong></p>
<pre><code>mpCamera = settings-&gt;camera1();
mpCamera = mpAtlas-&gt;AddCamera(mpCamera);

if(settings-&gt;needToUndistort())&#123;
    mDistCoef = settings-&gt;camera1DistortionCoef();
&#125;
else&#123;
    mDistCoef = cv::Mat::zeros(4,1,CV_32F);
&#125;

//TODO: missing image scaling and rectification
mImageScale = 1.0f;

mK = cv::Mat::eye(3,3,CV_32F);
mK.at&lt;float&gt;(0,0) = mpCamera-&gt;getParameter(0);
mK.at&lt;float&gt;(1,1) = mpCamera-&gt;getParameter(1);
mK.at&lt;float&gt;(0,2) = mpCamera-&gt;getParameter(2);
mK.at&lt;float&gt;(1,2) = mpCamera-&gt;getParameter(3);

mK_.setIdentity();
mK_(0,0) = mpCamera-&gt;getParameter(0);
mK_(1,1) = mpCamera-&gt;getParameter(1);
mK_(0,2) = mpCamera-&gt;getParameter(2);
mK_(1,2) = mpCamera-&gt;getParameter(3);
</code></pre>
<p>mpCamera是GeometricCamera类型的成员变量，第一行吧settings里储存的calibration1_传递给它。<br />
接下来执行mpAtlas对象的AddCamera()函数,mpAtlas对象里有一个成员变量std::vector&lt;GeometricCamera*&gt; mvpCameras,用来存储这个多地图系统下所用到的相机，这个函数就是往mvpCameras中添加一个相机。<br />
由于需要去畸变，又把settings里存储的畸变参数转为cv::Mat格式传递给成员变量mDistCoef。<br />
然后，把相机内参分别存储到mK和mK_中，mK是cv::Mat类型的，mK_是Eigen::Matrix3f类型的。</p>
<p><strong>2. 读取特征点参数</strong><br />
这一步是将ORBextractor类型的成员变量mpORBextractorLeft初始化，这里用到了ORBextractor类的构造函数，由于内容有点多，就把内容放在另一篇博客里了，详情见<a target="_blank" rel="noopener" href="https://www.jzhblog.top/2023/03/30/ORBSLAM3-NOTE-4/">ORBextractor.cc</a></p>
<pre><code>mpORBextractorLeft = new ORBextractor(nFeatures,fScaleFactor,nLevels,fIniThFAST,fMinThFAST);

if(mSensor==System::STEREO || mSensor==System::IMU_STEREO)
    mpORBextractorRight = new ORBextractor(nFeatures,fScaleFactor,nLevels,fIniThFAST,fMinThFAST);

if(mSensor==System::MONOCULAR || mSensor==System::IMU_MONOCULAR)
    mpIniORBextractor = new ORBextractor(5*nFeatures,fScaleFactor,nLevels,fIniThFAST,fMinThFAST);
</code></pre>
<p>构造Frame类时，若是刚开启追踪，使用的是mpIniORBextractor，之后都是用mpORBextractorLeft了。</p>
<p><strong>3.读取imu参数</strong><br />
imu这部分先不看了，先把纯单目看完，imu联合部分留到以后补充。</p>
<p>newParameterLoader(settings);执行完之后，执行一下代码，将另外几个成员变量初始化</p>
<pre><code>initID = 0; lastID = 0;
mbInitWith3KFs = false;
mnNumDataset = 0;
</code></pre>
<hr />
<h3 id="trackinggrabimagemonocular"><a class="markdownIt-Anchor" href="#trackinggrabimagemonocular"></a> Tracking::GrabImageMonocular()</h3>
<p>该函数就是把传来的彩色图转化为灰度图，然后对Frame类对象mCurrentFrame初始化，得到当前帧。具体看<a target="_blank" rel="noopener" href="https://www.jzhblog.top/2023/03/31/ORBSLAM3-NOTE-7/">Frame.cc</a>设置好mCurrentFrame的mNameFile和mnDataset后，调用Track()开始追踪。</p>
<hr />
<h3 id="trackingtrack"><a class="markdownIt-Anchor" href="#trackingtrack"></a> Tracking::Track()</h3>
<p><strong>1.从Atlas中取出当前active的地图</strong><br />
<strong>2.处理时间戳异常的情况，这里有分两种情况：</strong><br />
（1）如果当前图像时间戳比前一帧图像时间戳小，说明出错了，清除imu数据，调用CreateMapInAtlas()创建新的子地图。CreateMapInAtlas()的功能就是在Atlas中保存当前地图，创建新地图，所有跟状态相关的变量全部重置。<br />
（2）如果当前图像时间戳和前一帧图像时间戳大于1s，说明时间戳明显跳变了，直接返回。<br />
<strong>3.判断地图是否被更新</strong><br />
<strong>4.初始化</strong><br />
根据相机类型和带不带imu进行初始化，初始化时调用MonocularInitialization()。这里首先是创建了一个单目初始器，下面mState判断时，还是会直接返回，等第二帧到来后，再调用MonocularInitialization()才能彻底完成初始化，然后等待下一帧到来。<br />
<strong>5.系统成功初始化，下面是具体跟踪过程</strong><br />
这里就只看slam模式下的代码，这部分最关键的就是mState和bOk两个标志位的值，要注意观察其变化。</p>
<ul>
<li>若<strong>mState==OK</strong>
<ul>
<li>1.检查并更新上一帧被替换的MapPoints
<blockquote>
<p>这里调用了函数CheckReplacedInLastFrame()，局部建图线程则可能会对原有的地图点进行替换.在这里进行检查。过程很简单，遍历<code>mLastFrame</code>的所有地图点，若地图点的<code>mpReplaced</code>存在，则用<code>mpReplaced</code>替换该地图点。</p>
</blockquote>
</li>
<li>2.若运动模型是空的并且imu未初始化或刚完成重定位，跟踪参考关键帧；否则先用恒速模型跟踪，跟踪失败再换参考关键帧跟踪。
<blockquote>
<p>这里对bOk进行了改变，<strong>bOK</strong>=TrackReferenceKeyFrame()或TrackReferenceKeyFrame()，这两个函数写在后面了。</p>
</blockquote>
</li>
<li>3.若上面跟踪失败，即bOK==false，则要对<code>mState</code>进行更新。
<blockquote>
<p>1.如果当前帧距离上次重定位成功不到1s，且为单目+IMU 或者 双目+IMU模式，<strong>mState = LOST</strong><br />
2.当前地图中关键帧数目较多（大于10），且当前帧距离上次重定位帧超过1s或者非IMU模式，<strong>mState = RECENTLY_LOST</strong>，且要记录丢失时间，存在mTimeStampLost里。<br />
3.其他情况下，<strong>mState = LOST</strong></p>
</blockquote>
</li>
</ul>
</li>
<li>若<strong>mState!=OK</strong>
<ul>
<li>若<strong>mState == RECENTLY_LOST</strong>
<blockquote>
<p>由于我们看的纯单目，所以直接调用重定位函数，<strong>bOK</strong> = Relocalization()，若重定位失败，且当前帧时间和丢失时间超过3了，令<strong>mState = LOST</strong></p>
</blockquote>
</li>
<li>若<strong>mState == LOST</strong>,直接开启新地图，<em>返回</em>。</li>
</ul>
</li>
<li>若<strong>bOK==true</strong>，说明上一步跟踪成功，进行局部地图跟踪
<blockquote>
<p>这里调用了函数<code>TrackLocalMap()</code>,这里对bOK也进行了更改，<strong>bOK =</strong> TrackLocalMap()。<br />
虽然前面也进行了跟踪，但只是跟踪一帧得到初始位姿，这里搜索局部关键帧、局部地图点，和当前帧进行投影匹配，得到更多匹配的MapPoints后进行Pose优化。</p>
</blockquote>
</li>
<li>更新mState状态。
<ul>
<li>若<strong>bOK==true</strong>,说明上一步的局部地图跟踪也成功了，令<strong>mState = OK</strong>。</li>
<li>若<strong>bOK==false，但mState == OK</strong>
<blockquote>
<p>这里只有第一阶段跟踪成功，但第二阶段局部地图跟踪失败时执行，这里就是让<strong>mState=RECENTLY_LOST</strong>，记录丢失时间。</p>
</blockquote>
</li>
</ul>
</li>
<li>若<strong>bOK == true或mState==RECENTLY_LOST</strong>，更新速度，清除无效地图点，按需创建关键帧。
<ul>
<li>1.更新恒速运动模型
<blockquote>
<p>这里将上一帧到当前帧的变换存入了mVelocity，将mbVelocity置为true。</p>
</blockquote>
</li>
<li>2.清除观测不到的地图点</li>
<li>3.根据条件来判断是否插入关键帧
<blockquote>
<p>需要同时满足bNeedKF=true且bOK=true跟踪成功，bNeedKF的值是由函数NeedNewKeyFrame()得到的。若满足条件，则调用函数CreateNewKeyFrame()创建新关键帧</p>
</blockquote>
</li>
<li>删除当前帧中那些在BA中检测为外点的地图点。</li>
</ul>
</li>
<li>若<strong>mState==LOST</strong>
<blockquote>
<p>如果地图中关键帧小于10，重置当前地图，退出当前跟踪，若大于10，保存当前地图，创建新的地图。</p>
</blockquote>
</li>
<li>设置了参考关键帧,保存上一帧的数据,当前帧变上一帧
<blockquote>
<p>mCurrentFrame.mpReferenceKF = mpReferenceKF;<br />
mLastFrame = Frame(mCurrentFrame);</p>
</blockquote>
</li>
</ul>
<p><strong>6.记录位姿信息，用于最后保存所有的轨迹</strong></p>
  <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">if(mCurrentFrame.isSet())</span><br><span class="line">      &#123;</span><br><span class="line">          // 计算相对姿态Tcr = Tcw * Twr, Twr = Trw^-1</span><br><span class="line">          Sophus::SE3f Tcr_ = mCurrentFrame.GetPose() * mCurrentFrame.mpReferenceKF-&gt;GetPoseInverse();</span><br><span class="line">          mlRelativeFramePoses.push_back(Tcr_);</span><br><span class="line">          mlpReferences.push_back(mCurrentFrame.mpReferenceKF);</span><br><span class="line">          mlFrameTimes.push_back(mCurrentFrame.mTimeStamp);</span><br><span class="line">          mlbLost.push_back(mState==LOST);</span><br><span class="line">      &#125;</span><br><span class="line">      else</span><br><span class="line">      &#123;</span><br><span class="line">          // This can happen if tracking is lost</span><br><span class="line">          // 如果跟踪失败，则相对位姿使用上一次值</span><br><span class="line">          mlRelativeFramePoses.push_back(mlRelativeFramePoses.back());</span><br><span class="line">          mlpReferences.push_back(mlpReferences.back());</span><br><span class="line">          mlFrameTimes.push_back(mlFrameTimes.back());</span><br><span class="line">          mlbLost.push_back(mState==LOST);</span><br><span class="line">      &#125;</span><br></pre></td></tr></table></figure>
<hr />
<h3 id="trackingmonocularinitialization"><a class="markdownIt-Anchor" href="#trackingmonocularinitialization"></a> Tracking::MonocularInitialization()</h3>
<ul>
<li>
<p><strong>如果单目初始器还没有被创建，则创建。</strong><br />
这里完成了一些成员变量的初始化，这里就看一下对应成员变量的作用。</p>
<blockquote>
<p>mInitialFrame将当前帧作为初始帧</p>
</blockquote>
<blockquote>
<p>mvbPrevMatched用来存储当前帧的所有特征点</p>
</blockquote>
<blockquote>
<p>初始化mvIniMatches，保存参考帧匹配到的特征点，index保存是参考帧对应特征点索引，值保存的是匹配到特征点索引。</p>
</blockquote>
<p>成员变量初始化完成之后，将标志位mbReadyToInitializate置为true，等待下一帧。</p>
</li>
<li>
<p><strong>单目初始器创建完成，且第二帧到来后</strong></p>
<ul>
<li>判断当前帧特征点数量是否足够，不够则重新构造初始器</li>
<li>在mInitialFrame与mCurrentFrame中找匹配的特征点对
<ul>
<li>创建ORBmatcher类对象matcher<pre class="highlight"><code class="">ORBmatcher matcher(0.9,true);
</code></pre>
</li>
<li>调用matcher的SearchForInitialization()函数进行特征点匹配，具体见<a target="_blank" rel="noopener" href="https://www.jzhblog.top/2023/04/10/ORBSLAM3-NOTE-8/">ORBmatcher</a></li>
<li>验证匹配结果，如果初始化的两帧之间的匹配点太少，重新初始化</li>
</ul>
</li>
<li>通过H模型或F模型进行单目初始化，得到两帧间相对运动、初始MapPoints，具体见<a target="_blank" rel="noopener" href="https://www.jzhblog.top/2023/04/11/ORBSLAM3-NOTE-9/">TwoViewReconstruction.cc</a></li>
<li>初始化成功后，删除那些无法进行三角化的匹配点</li>
<li>将初始化的第一帧作为世界坐标系，因此第一帧变换矩阵为单位矩阵,把之前得到的两帧之间的变换矩阵存入当前帧对象中。</li>
<li>调用CreateInitialMapMonocular()函数，创建初始化地图点MapPoints。</li>
</ul>
</li>
</ul>
<hr />
<h3 id="trackingcreateinitialmapmonocular"><a class="markdownIt-Anchor" href="#trackingcreateinitialmapmonocular"></a> Tracking::CreateInitialMapMonocular()</h3>
<p>1.把单目初始化时候的参考帧和当前帧作为关键帧，创建两个关键帧对象。<br />
2.将这两个关键帧的描述子转为BoW，调用了函数ComputeBoW(),详情见<a target="_blank" rel="noopener" href="https://www.jzhblog.top/2023/04/13/ORBSLAM3-NOTE-10/">KeyFrame.cc</a><br />
3.将这两个关键帧插入到<code>mpAtlas</code>的成员变量<code>mpCurrentMap</code>中。<br />
4.遍历匹配点，进行一系列操作</p>
<ul>
<li>4.1 用3D点构造地图点
<blockquote>
<p>这步就是用遍历的特征点对应的3D点创建MapPoint*类对象pMP。</p>
</blockquote>
</li>
<li>4.2 为该MapPoint添加属性
<ul>
<li>4.2.1 首先把MapPoint添加到两个关键帧里面去。</li>
</ul>
<blockquote>
<p>就是把MapPoint存入pKFini,pKFcur的成员变量<code>mvpMapPoints</code>容器中，<strong>存的位置就是当前遍历到的特征点索引值</strong>。</p>
</blockquote>
<ul>
<li>
<p>4.2.2 给MapPoint添加能观察到它的关键帧及对应特征点的索引值,调用了函数AddObservation(),具体看<a target="_blank" rel="noopener" href="https://www.jzhblog.top/2023/04/13/ORBSLAM3-NOTE-11/">MapPoint.cc</a>。</p>
</li>
<li>
<p>4.2.3 从众多观测到该MapPoint的特征点中挑选最有代表性的描述子,调用函数ComputeDistinctiveDescriptors()。</p>
</li>
</ul>
<blockquote>
<p>该函数简单来说就是遍历能观察到它的关键帧，根据保存的特征点索引值，获取所有描述子，计算描述子之间的两两距离，最好的描述子与其他描述子应该具有最小的距离中值，将这个最好的描述子存入成员变量<code>mDescriptor</code>中。</p>
</blockquote>
<ul>
<li>更新该MapPoint平均观测方向以及观测距离的范围，具体看<a target="_blank" rel="noopener" href="https://www.jzhblog.top/2023/04/13/ORBSLAM3-NOTE-11/">MapPoint.cc</a>。</li>
</ul>
</li>
<li>4.3 将MapPoint存入<code>mCurrentFrame</code>的<code>mvpMapPoints</code>容器中，位置就是对应特征点的索引值。同时，将<code>mvbOutlier</code>容器同样位置存入false，表示该特征点不是异常值。</li>
<li>5.更新关键帧间的连接关系，调用了函数UpdateConnections()，具体见<a target="_blank" rel="noopener" href="https://www.jzhblog.top/2023/04/13/ORBSLAM3-NOTE-10/">KeyFrame.cc</a>。</li>
<li>6.全局BA优化，同时优化所有位姿和三维点。
<blockquote>
<p>调用了函数Optimizer::GlobalBundleAdjustemnt(),它接收两个参数，一个是优化目标，此处即是mpMap，里面包括了关键帧pose和地图点坐标；第二个是迭代次数，此处为20次。在函数内部，调用了BundleAdjustment函数——实现了最小化重投影误差的优化问题，并利用g2o框架求解。</p>
</blockquote>
</li>
<li>7.将平移尺度和3D点尺度归一化。
<blockquote>
<p>方法就是求得当前3D点的深度中位数，将平移向量和3D点坐标除以该值。</p>
</blockquote>
</li>
<li>8.将关键帧插入局部地图，更新归一化后的位姿、局部地图点，更新跟踪状态变量mState。
<blockquote>
<p>这里会把两个关键帧插入<code>mpLocalMapper</code>的<code>mlNewKeyFrames</code>列表中,这样LocalMapping线程就能接收到关键帧来处理了。</p>
</blockquote>
</li>
</ul>
<p>到此为止，单目初始化终于完成了，这部分真的看了不少时间啊。</p>
<hr />
<h3 id="trackingtrackreferencekeyframe"><a class="markdownIt-Anchor" href="#trackingtrackreferencekeyframe"></a> Tracking::TrackReferenceKeyFrame()</h3>
<ol>
<li>将当前帧的描述子转化为BoW向量</li>
<li>通过词袋BoW加速当前帧与参考帧之间的特征点匹配
<blockquote>
<p>这里调用了函数ORBmatcher::SearchByBoW(),其实和我们之前看的ORBmatcher::SearchForTriangulation()中间部分差不多，就一点差别，就不细讲了。</p>
</blockquote>
</li>
<li>将上一帧的位姿态作为当前帧位姿的初始值</li>
<li>通过优化3D-2D的重投影误差来获得位姿
<blockquote>
<p>这里其实就是对单帧位姿的BA优化，优化过程中还会对残差进行卡方检验，由此确定内外点。</p>
</blockquote>
</li>
<li>剔除优化后的匹配点中的外点
<blockquote>
<p>这里由于第四步已经找出内外点了，所以只需遍历mvpMapPoints，若此时mvbOutlier为true，则将该点先拷贝到pMP中，将mvpMapPoints中的该点置为空，mvbOutlier置为false，再将pMP的mbTrackInView置为false，mnLastFrameSeen赋值为mCurrentFrame的mnId;</p>
</blockquote>
</li>
<li>跟踪成功的数目超过10才认为跟踪成功，否则跟踪失败</li>
</ol>
<hr />
<h3 id="trackingtrackwithmotionmodel"><a class="markdownIt-Anchor" href="#trackingtrackwithmotionmodel"></a> Tracking::TrackWithMotionModel()</h3>
<p>1.更新上一帧的位姿</p>
<blockquote>
<p>调用了函数UpdateLastFrame(),由于是单目模式，所以这里的操作很少，简单介绍一下：<br />
首先，得到lastframe的参考关键帧到lastframe的位姿变换Tlr，这个存储在mlRelativeFramePoses，然后再用Tlr乘以参考关键帧的位姿Trw，就得到了上一张位姿Tlw。</p>
</blockquote>
<p>2.根据恒速模型得到当前帧的初始位姿。</p>
<blockquote>
<p>这里就是假定相机恒速运动，每次位姿变化相同，当前的位姿就为mVelocity * mLastFrame.GetPose()。</p>
</blockquote>
<p>3.用上一帧地图点进行投影匹配，如果匹配点不够，则扩大搜索半径再来一次。</p>
<blockquote>
<p>这里调用了函数<code>SearchByProjection()</code>,这里不用词袋加速匹配是因为我们通过恒速模型已经得到了初始位姿，可以直接通过2D-3D的投影关系搜索匹配点，速度更快。<br />
具体步骤简单来说就是把3D点位姿变换，然后投影得到2D坐标，以该坐标为圆形，在搜索半径内找到可以匹配的点，然后就是找最佳匹配点，用旋转差直方图来筛掉错误匹配对等一系列操作了。</p>
</blockquote>
<p>4.通过优化3D-2D的重投影误差来获得位姿</p>
<blockquote>
<p>这里和上面的参考关键帧跟踪一样，就是当前帧的初始位姿不同。</p>
</blockquote>
<p>5.剔除优化后的匹配点中的外点<br />
6.跟踪成功的数目超过10才认为跟踪成功，否则跟踪失败</p>
<hr />
<h3 id="trackingrelocalization"><a class="markdownIt-Anchor" href="#trackingrelocalization"></a> Tracking::Relocalization()</h3>
<hr />
<h3 id="trackingtracklocalmap"><a class="markdownIt-Anchor" href="#trackingtracklocalmap"></a> Tracking::TrackLocalMap()</h3>
<p>1.更新局部关键帧和局部地图点</p>
<blockquote>
<p>调用函数UpdateLocalMap()，该函数中有两个函数UpdateLocalKeyFrames()和UpdateLocalPoints()，分别实现局部关键帧和局部地图点的更新，用于局部跟踪。<br />
<strong>UpdateLocalKeyFrames()</strong>:该函数的作用就是更新成员变量<code>mvpLocalKeyFrames</code>,将三种关键帧存入该向量中，分别是①能观测到当前帧地图点的关键帧，也称一级共视关键帧;②一级共视关键帧的共视关键帧，称为二级共视关键帧;③一级共视关键帧的子关键帧、父关键帧。<br />
<strong>UpdateLocalPoints()</strong>:该函数的作用是更新成员变量<code>mvpLocalMapPoints</code>,遍历<code>mvpLocalKeyFrames</code>，将其中关键帧的地图点存入该变量。</p>
</blockquote>
<p>2.筛选局部地图中新增的在视野范围内的地图点，得到更多的匹配关系</p>
<blockquote>
<p>调用函数SearchLocalPoints()。</p>
</blockquote>
<p>3.利用前面新增的更多的匹配关系，BA优化得到更准确位姿<br />
4.遍历当前帧地图点，更新当前帧的地图点被观测程度，并统计跟踪局部地图后匹配数目</p>
<blockquote>
<p>这里就是更新两个成员变量，若当前帧的地图点不是外点，该地图点的<code>mnFound</code><ins>。成员变量<code>mnMatchesInliers</code></ins>，记录当前帧跟踪到的地图点数目，用于统计跟踪效果。<br />
5.纯单目情况下，<code>mnMatchesInliers</code>大于30，则跟踪成功。</p>
</blockquote>
<hr />
<h3 id="trackingsearchlocalpoints"><a class="markdownIt-Anchor" href="#trackingsearchlocalpoints"></a> Tracking::SearchLocalPoints()</h3>
<p>1.遍历当前帧的地图点，标记这些地图点不参与之后的投影搜索匹配。</p>
<pre><code>// 更新能观测到该点的帧数加1(被当前帧观测了)
pMP-&gt;IncreaseVisible(); //mnVisible++
// 标记该点被当前帧观测到
pMP-&gt;mnLastFrameSeen = mCurrentFrame.mnId;
// 标记该点在后面搜索匹配时不被投影，因为已经有匹配了
pMP-&gt;mbTrackInView = false;
pMP-&gt;mbTrackInViewR = false;
</code></pre>
<p>2.判断所有局部地图点中除当前帧地图点外的点，是否在当前帧视野范围内</p>
<blockquote>
<p>调用函数isInFrustum(),详情见<a target="_blank" rel="noopener" href="https://www.jzhblog.top/2023/04/13/ORBSLAM3-NOTE-11/">MapPoint.cc</a>,若在视野内，则pMP-&gt;IncreaseVisible()，nToMatch++。接下来判断pMP的mbTrackInView是否为true(若在视野内，isInFrustum()会将其置为true)，然后将该3D点的投影坐标存入mCurrentFrame.mmProjectPoints[ pMP-&gt;mnId]中。</p>
</blockquote>
<p>3.设置搜索阈值，调用函数SearchByProjection()进行匹配。</p>
<blockquote>
<p>这里讲一下SearchByProjection()(由于这个函数有5种重载，就不在ORBmatcher.cc文件里一个个列出来讲了，毕竟有很多地方都是重复的)。<br />
1.遍历有效的局部地图点，主要是根据mbTrackInView(判断地图点是否在视野内时更新过)，bFarPoints和thFarPoints判断<br />
2.设定搜索搜索窗口的大小。若当前视角和平均视角夹角较小时, r取2.5，否则取4<br />
3.通过投影点以及搜索窗口和预测的尺度进行搜索, 找出搜索半径内的候选匹配点索引<br />
接下来就是那些通用步骤了，不过这里不用旋转差直方图来筛选。</p>
</blockquote>
<hr />
<h3 id="trackingneednewkeyframe"><a class="markdownIt-Anchor" href="#trackingneednewkeyframe"></a> Tracking::NeedNewKeyFrame()</h3>
<p>该函数用来判断当前帧是否需要插入关键帧<br />
1.纯跟踪模式下不插入关键帧，如果局部地图被闭环检测使用，则不插入关键帧<br />
2.如果距离上一次重定位比较近，或者关键帧数目超出最大限制，不插入关键帧<br />
3.得到参考关键帧跟踪到的地图点数量</p>
<blockquote>
<p>只有当地图点被2或3个以上关键帧观测到才会被计数，结果存入nRefMatches中。</p>
</blockquote>
<p>4.查询局部地图管理器是否繁忙,也就是当前能否接受新的关键帧<br />
5.决策是否需要插入关键帧</p>
<blockquote>
<p>单目情况下，要进行以下判断：<br />
条件a1:很长时间没有插入关键帧<br />
条件a2:满足插入关键帧的最小间隔并且localMapper处于空闲状态<br />
条件b:mnMatchesInliers&lt; nRefMatches*0.9且mnMatchesInliers&gt;15<br />
若a1或a2任一满足，且b满足，则local mapping线程空闲时或者正在做imu初始化时可以直接插入，不空闲的时候要根据情况插入。</p>
</blockquote>
<p>以上判断是纯单目下的，若加上imu或者是双目，rgbd会复杂一些。</p>
<hr />
<h3 id="trackingcreatenewkeyframe"><a class="markdownIt-Anchor" href="#trackingcreatenewkeyframe"></a> Tracking::CreateNewKeyFrame()</h3>
<p>1.将当前帧构造成关键帧<br />
2.将当前关键帧设置为当前帧的参考关键帧</p>
<pre><code>mpReferenceKF = pKF;
mCurrentFrame.mpReferenceKF = pKF;

if(mpLastKeyFrame)
&#123;
    pKF-&gt;mPrevKF = mpLastKeyFrame;
    mpLastKeyFrame-&gt;mNextKF = pKF;
&#125;
</code></pre>
<p>3.关键帧插入到列表mlNewKeyFrames中，等待local mapping线程处理</p>
<pre><code>mpLocalMapper-&gt;InsertKeyFrame(pKF);

// 插入好了，允许局部建图停止
mpLocalMapper-&gt;SetNotStop(false);

// 当前帧成为新的关键帧，更新
mnLastKeyFrameId = mCurrentFrame.mnId;
mpLastKeyFrame = pKF;
</code></pre>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://example.com/2023/03/27/ORBSLAM3_NOTE_2/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Hexo">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2023/03/27/ORBSLAM3_NOTE_2/" itemprop="url">ORB-SLAM3源码阅读:System</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2023-03-27T20:09:53+08:00">
                2023-03-27
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="orbslam3学习笔记2"><a class="markdownIt-Anchor" href="#orbslam3学习笔记2"></a> ORBSLAM3学习笔记(2)</h1>
<p>这篇主要是对System.cc文件的阅读，主要是看System类的构造函数，因为main函数中主要用了这个函数。</p>
<h2 id="systemspancc"><a class="markdownIt-Anchor" href="#systemspancc"></a> System.</span>cc</h2>
<h3 id="systemsystem"><a class="markdownIt-Anchor" href="#systemsystem"></a> System::System()</h3>
<p>构造函数功能虽然简单，但这里完成了对这个系统的初始化，所以还是要讲得细一点，主要是通过这个构造函数，了解一下整个orbslam3有哪些重要的类，这些类的成员变量等。<br />
先整体介绍一下构造函数的具体流程，该函数主要完成了以下几个步骤：<br />
1.读取当前传感器类型<br />
2.读取配置文件<br />
3.加载Vocabulary<br />
4.创建关键帧库<br />
5.创建多地图<br />
6.创建线程 跟踪、局部建图、回环、显示路径。</p>
<p>首先看构造函数引用的参数以及部分成员变量的初始化</p>
<pre><code>System::System(const string &amp;strVocFile,    //词袋文件所在路径
    const string &amp;strSettingsFile,          //配置文件所在路径
    const eSensor sensor,                   //传感器类型
    const bool bUseViewer,                  //是否使用可视化界面
    const int initFr,                       //表示初始化帧的id,开始设置为0 
    const string &amp;strSequence               //序列名,在跟踪线程和局部建图线程用得到
    ):
    mSensor(sensor),                        //初始化传感器类型
    mpViewer(static_cast&lt;Viewer*&gt;(NULL)),   //给Viewer类初始化空指针对象
    mbReset(false),mbResetActiveMap(false),
    mbActivateLocalizationMode(false),      //是否开启局部地图定位开关 
    mbDeactivateLocalizationMode(false), 
    mbShutDown(false)
</code></pre>
<p>参数的基本含义都注释在上面了，这里就先不多做赘述，马上使用到这些参数时，会详细地说明。<br />
其中&amp;strVocFile，&amp;strSettingsFile，sensor都是main函数调用构造函数是传递过来的。其中sensor是MONOCULAR，根据System.h文件中的枚举列表可知，sensor = 0。</p>
<pre><code>enum eSensor&#123;
    MONOCULAR=0,
    STEREO=1,
    RGBD=2,
    IMU_MONOCULAR=3,
    IMU_STEREO=4,
    IMU_RGBD=5,
&#125;;
</code></pre>
<hr />
<h4 id="settings类对象的初始化"><a class="markdownIt-Anchor" href="#settings类对象的初始化"></a> Settings类对象的初始化</h4>
<p>配置文件的读取主要是用了opencv库里的函数，读取完之后，我们就用读取到的内容初始化System类的成员变量settings_。</p>
<pre><code>settings_ = new Settings(strSettingsFile,mSensor);
</code></pre>
<p>strSettingsFile就是我们读取到的配置文件，mSensor就是传感器类型。接下来去看<strong>Settings类的构造函数</strong>。</p>
<p>先看构造函数引用的参数以及部分成员变量的初始化</p>
<pre><code>Settings::Settings(
    const std::string &amp;configFile,  //配置文件
    const int &amp;sensor               //传感器类型
    ): 
    bNeedToUndistort_(false),       //是否需要去畸变 
    bNeedToRectify_(false), 
    bNeedToResize1_(false),
    bNeedToResize2_(false)
</code></pre>
<p>Settings类的构造函数先确认configFile能否打开，然后调用函数</p>
<pre><code>readCamera1(fSettings);
</code></pre>
<p>该函数主要实现了将三个setting类的成员变量初始化:<br />
<strong>1.GeometricCamera* calibration1_</strong><br />
calibration1_是GeometricCamera类对象，由于GeometricCamera类是Pinhole的基类，故创建calibration1_对象用的是Pinhole的构造函数</p>
<pre><code>Pinhole(const std::vector&lt;float&gt; _vParameters) : GeometricCamera(_vParameters), tvr(nullptr) &#123;
    assert(mvParameters.size() == 4);
    mnId=nNextId++;
    mnType = CAM_PINHOLE;
&#125;
</code></pre>
<p>GeometricCamera类有三个成员变量，分别是</p>
<pre><code>std::vector&lt;float&gt; mvParameters;
unsigned int mnId;
unsigned int mnType;
</code></pre>
<p>mvParameters向量用来存储相机内参，mnId为相机id，mnId=nNextId++，nNextId的缺省值为0。mnType = CAM_PINHOLE，CAM_PINHOLE = 0，CAM_FISHEYE = 1。<br />
故calibration1_对象中保存了相机的内参，id和类型。</p>
<p><strong>2.std::vector<float> vPinHoleDistorsion1_</strong><br />
即相机的畸变参数，畸变参数主要包括径向畸变的k1,k2,k3(有时没有这个k3)和切向畸变的p1,p2。</p>
<p><strong>3.bool bNeedToUndistort_</strong><br />
判读相机是否需要去畸变，若相机为单目或rgbd，且vPinHoleDistorsion1_的size不为零，则该值为true。</p>
<p>读取完Camera1再根据sensor_类型判断是否需要调用readCamera2(fSettings)函数，由于我现在看的是单目相机，就不需要执行这个函数了。然后调用函数</p>
<pre><code>readImageInfo(fSettings);
</code></pre>
<p>该语句将cv::Size originalImSize_，float fps_，bool bRGB_ 这三个setting类的成员变量初始化。分别为图像原始大小，帧率，和rgb通道类型。</p>
<p>接着根据sensor_类型判断是否需要调用readIMU(fSettings)和readRGBD(fSettings)。然后调用函数</p>
<pre><code>readORB(fSettings);
</code></pre>
<p>该函数初始化成员变量<br />
<strong>int nFeatures_</strong> 指定要提取的特征点数目<br />
<strong>float scaleFactor_</strong> 指定图像金字塔的缩放系数<br />
<strong>int nLevels_</strong> 指定图像金字塔的层数<br />
<strong>int initThFAST_</strong> 指定初始的FAST特征点提取参数，可以提取出最明显的角点<br />
<strong>int minThFAST_</strong> 如果初始阈值没有检测到角点，降低到这个阈值提取出弱一点的角点</p>
<p>接下来仍然是调用函数初始化成员变量，分别调用了readViewer(fSettings)，readLoadAndSave(fSettings)，readOtherParameters(fSettings)，以下变量被初始化</p>
<pre><code>/*
* Viewer stuff
*/
float keyFrameSize_;
float keyFrameLineWidth_;
float graphLineWidth_;
float pointSize_;
float cameraSize_;
float cameraLineWidth_;
float viewPointX_, viewPointY_, viewPointZ_, viewPointF_;
float imageViewerScale_;

/*
* Save &amp; load maps
*/
std::string sLoadFrom_, sSaveto_;

/*
* Other stuff
*/
float thFarPoints_;
</code></pre>
<p>Viewer相关的参数目前还不知道是干啥的，以后看到了再来更新。sLoadFrom_, sSaveto_如果根据Examples目录提供的文件，这两项是空的。</p>
<p>总结，Settings类主要就是将配置文件里的数据读取到Settings类的对象中，总体比较简单。</p>
<hr />
<p>settings_初始化完成后，保存及加载地图的名字，目前这两个参数都是空的。</p>
<pre><code>mStrLoadAtlasFromFile = settings_-&gt;atlasLoadFile();
mStrSaveAtlasToFile = settings_-&gt;atlasSaveFile();
</code></pre>
<p>然后，确认是否激活回环，默认是开着的。建立一个新的ORB字典</p>
<pre><code>mpVocabulary = new ORBVocabulary();
</code></pre>
<p>mpVocabulary是ORBVocabulary类型的，ORBVocabulary是自定义类型，本质是DBoW2::TemplatedVocabulary&lt;DBoW2::FORB::TDescriptor，</span>DBoW2::FORB&gt;类型。关于DBow2的关键代码的讲解，可以看<a target="_blank" rel="noopener" href="https://blog.csdn.net/yys2324826380/article/details/105453134/">ORBSLAM中的DBoW2关键代码注释</a>，<a target="_blank" rel="noopener" href="https://blog.51cto.com/u_14439393/5724573">ORB_SLAM2源码中字典使用细节</a>。</p>
<hr />
<h4 id="keyframedatabase类对象的初始化"><a class="markdownIt-Anchor" href="#keyframedatabase类对象的初始化"></a> KeyFrameDatabase类对象的初始化</h4>
<p>确认词袋文件可以加载后，初始化成员变量mpKeyFrameDatabase，这是关键帧数据库</p>
<pre><code>mpKeyFrameDatabase = new KeyFrameDatabase(*mpVocabulary);
</code></pre>
<p>下面我们简单看一下KeyFrameDatabase类，首先看它有哪些成员变量</p>
<pre><code>protected:
// Associated vocabulary
const ORBVocabulary* mpVoc;

// Inverted file
std::vector&lt;list&lt;KeyFrame*&gt; &gt; mvInvertedFile;

// For save relation without pointer, this is necessary for save/load function
std::vector&lt;list&lt;long unsigned int&gt; &gt; mvBackupInvertedFileId;

// Mutex
std::mutex mMutex;
</code></pre>
<p>首先，它包含一个词袋对象mpVoc，mvInvertedFile是倒排索引，mvInvertedFile[i]表示包含了第i个word id的所有关键帧，数据库的主要内容。这些关键帧的添加用了该类的成员函数void add(KeyFrame* pKF)。mvBackupInvertedFileId目前还不懂QAQ，以后再更新。mMutex是线程锁。<br />
接下来看KeyFrameDatabase类的构造函数</p>
<pre><code>// 构造函数
KeyFrameDatabase::KeyFrameDatabase(const ORBVocabulary &amp;voc) : mpVoc(&amp;voc)
&#123;
    mvInvertedFile.resize(voc.size());
&#125;
</code></pre>
<p>这里很明显就是把之前得到的词袋文件赋给mpVoc，再把mvInvertedFile向量的size变为词袋size。</p>
<hr />
<h4 id="atlas类对象的初始化"><a class="markdownIt-Anchor" href="#atlas类对象的初始化"></a> Atlas类对象的初始化</h4>
<p>关键帧数据库创建完毕，创建多地图，参数0表示初始化关键帧id为0</p>
<pre><code>mpAtlas = new Atlas(0);
</code></pre>
<p>直接来看Atlas类的构造函数</p>
<pre><code>Atlas::Atlas(int initKFid) : mnLastInitKFidMap(initKFid), mHasViewer(false)
&#123;
    mpCurrentMap = static_cast&lt;Map *&gt;(NULL);
    CreateNewMap();
&#125;
</code></pre>
<p>mpCurrentMap是Atlas类的成员变量，Map类型，表示当前地图，我们先给它一个空指针，然后看CreateNewMap()函数。</p>
<pre><code>void Atlas::CreateNewMap()
&#123;
    // 锁住地图集
    unique_lock&lt;mutex&gt; lock(mMutexAtlas);
    cout &lt;&lt; &quot;Creation of new map with id: &quot; &lt;&lt; Map::nNextId &lt;&lt; endl;
    // 如果当前活跃地图有效，先存储当前地图为不活跃地图后退出
    if (mpCurrentMap)
    &#123;
        // mnLastInitKFidMap为当前地图创建时第1个关键帧的id，它是在上一个地图最大关键帧id的基础上增加1
        if (!mspMaps.empty() &amp;&amp; mnLastInitKFidMap &lt; mpCurrentMap-&gt;GetMaxKFid())
            mnLastInitKFidMap = mpCurrentMap-&gt;GetMaxKFid() + 1; // The init KF is the next of current maximum

        // 将当前地图储存起来，其实就是把mIsInUse标记为false
        mpCurrentMap-&gt;SetStoredMap();
        cout &lt;&lt; &quot;Stored map with ID: &quot; &lt;&lt; mpCurrentMap-&gt;GetId() &lt;&lt; endl;

        // if(mHasViewer)
        //     mpViewer-&gt;AddMapToCreateThumbnail(mpCurrentMap);
    &#125;
    cout &lt;&lt; &quot;Creation of new map with last KF id: &quot; &lt;&lt; mnLastInitKFidMap &lt;&lt; endl;

    mpCurrentMap = new Map(mnLastInitKFidMap);  //新建地图
    mpCurrentMap-&gt;SetCurrentMap();              //设置为活跃地图
    mspMaps.insert(mpCurrentMap);               //插入地图集
&#125;
</code></pre>
<p>现在mpCurrentMap为空，则按照注释，完成新建地图，设置为活跃地图，插入地图集三个步骤。新建地图就是把mpCurrentMap初始化，设置map的id。</p>
<hr />
<p>接下来将用于显示帧和地图的成员变量初始化，由Viewer调用。</p>
<pre><code>mpFrameDrawer = new FrameDrawer(mpAtlas);
mpMapDrawer = new MapDrawer(mpAtlas, strSettingsFile, settings_);
</code></pre>
<p>先看FrameDrawer类的构造函数</p>
<pre><code>FrameDrawer::FrameDrawer(Atlas* pAtlas):both(false),mpAtlas(pAtlas)
&#123;
    mState=Tracking::SYSTEM_NOT_READY;
    mIm = cv::Mat(480,640,CV_8UC3, cv::Scalar(0,0,0));
    mImRight = cv::Mat(480,640,CV_8UC3, cv::Scalar(0,0,0));
&#125;
</code></pre>
<p>基本就是对画布初始化了一下，关于FrameDrawer类的讲解可以看<a target="_blank" rel="noopener" href="https://blog.csdn.net/qq_45794281/article/details/122026326">这篇博客</a>。</p>
<p>再看MapDrawer类的构造函数</p>
<pre><code>MapDrawer::MapDrawer(Atlas* pAtlas, const string &amp;strSettingPath, Settings* settings):mpAtlas(pAtlas)
&#123;
    if(settings)&#123;
        newParameterLoader(settings);
    &#125;
    else&#123;
        cv::FileStorage fSettings(strSettingPath, cv::FileStorage::READ);
        bool is_correct = ParseViewerParamFile(fSettings);

        if(!is_correct)
        &#123;
            std::cerr &lt;&lt; &quot;**ERROR in the config file, the format is not correct**&quot; &lt;&lt; std::endl;
            try
            &#123;
                throw -1;
            &#125;
            catch(exception &amp;e)
            &#123;

            &#125;
        &#125;
    &#125;
&#125;
</code></pre>
<p>这里其实就是调用了newParameterLoader(settings)函数，根据settings对成员变量进行赋值。</p>
<pre><code>void MapDrawer::newParameterLoader(Settings *settings) &#123;
    mKeyFrameSize = settings-&gt;keyFrameSize();
    mKeyFrameLineWidth = settings-&gt;keyFrameLineWidth();
    mGraphLineWidth = settings-&gt;graphLineWidth();
    mPointSize = settings-&gt;pointSize();
    mCameraSize = settings-&gt;cameraSize();
    mCameraLineWidth  = settings-&gt;cameraLineWidth();
&#125;
</code></pre>
<hr />
<h4 id="tracking类对象的初始化"><a class="markdownIt-Anchor" href="#tracking类对象的初始化"></a> Tracking类对象的初始化</h4>
<p>FrameDrawer和MapDrawer初始化完成，接下来对成员变量mpTracker进行初始化</p>
<pre><code>mpTracker = new Tracking(this, mpVocabulary,mpFrameDrawer, mpMapDrawer,
                         mpAtlas, mpKeyFrameDatabase, strSettingsFile, mSensor, settings_, strSequence);
</code></pre>
<p>这行代码调用了Tracking类的构造函数，具体内容就写在博客<a target="_blank" rel="noopener" href="https://www.jzhblog.top/2023/03/28/ORBSLAM3_NOTE_3/">Tracking.cc</a>里了。</p>
<hr />
<h4 id="创建并开启local-mapping线程"><a class="markdownIt-Anchor" href="#创建并开启local-mapping线程"></a> 创建并开启local mapping线程</h4>
<p>Tracking类对象的初始化完成后，创建并开启local mapping线程。首先初始化LocalMapping类对象</p>
<pre><code>mpLocalMapper = new LocalMapping(this, mpAtlas, mSensor==MONOCULAR || mSensor==IMU_MONOCULAR,
                                 mSensor==IMU_MONOCULAR || mSensor==IMU_STEREO || mSensor==IMU_RGBD, strSequence);
</code></pre>
<p>构造函数在LocalMapping.cc中，故具体讲解就放在<a href="">LocalMapping.cc</a>中了。接下来看local mapping线程的创建</p>
<pre><code>mptLocalMapping = new thread(&amp;ORB_SLAM3::LocalMapping::Run,mpLocalMapper);
</code></pre>
<p>这段代码是在创建一个新的线程，并将线程执行的入口点设置为 ORB_SLAM3::LocalMapping::Run 函数，同时传入一个参数 mpLocalMapper。关于LocalMapping::Run 函数，由于local mapping线程刚创建时，Tracking线程还未创建，故没有关键帧传入，此时LocalMapping::Run()就是每3000ms检查mlNewKeyFrames列表里有没有关键帧。接收到关键帧后就要进行一系列处理，具体步骤就放在<a target="_blank" rel="noopener" href="https://www.jzhblog.top/2023/03/30/ORBSLAM3-NOTE-5/">LocalMapping.cc</a>中了。我们可以先不管，继续往下看。</p>
<p>上面执行完后(LocalMapping::Run 函数还在子线程中继续跑)，执行下面的内容，对mpLocalMapper对象剩下的一些成员变量初始化。</p>
<pre><code>// 设置最远3D地图点的深度值，如果超过阈值，说明可能三角化不太准确，丢弃
if(settings_)
    mpLocalMapper-&gt;mThFarPoints = settings_-&gt;thFarPoints();
else
    mpLocalMapper-&gt;mThFarPoints = fsSettings[&quot;thFarPoints&quot;];
// ? 这里有个疑问,C++中浮点型跟0比较是否用精确?
if(mpLocalMapper-&gt;mThFarPoints!=0)
&#123;
    cout &lt;&lt; &quot;Discard points further than &quot; &lt;&lt; mpLocalMapper-&gt;mThFarPoints &lt;&lt; &quot; m from current camera&quot; &lt;&lt; endl;
    mpLocalMapper-&gt;mbFarPoints = true;
&#125;
else
    mpLocalMapper-&gt;mbFarPoints = false;
</code></pre>
<hr />
<h4 id="创建并开启闭环线程"><a class="markdownIt-Anchor" href="#创建并开启闭环线程"></a> 创建并开启闭环线程</h4>
<pre><code>mpLoopCloser = new LoopClosing(mpAtlas, mpKeyFrameDatabase, mpVocabulary, mSensor!=MONOCULAR, activeLC); // mSensor!=MONOCULAR);
mptLoopClosing = new thread(&amp;ORB_SLAM3::LoopClosing::Run, mpLoopCloser);
</code></pre>
<p>这里和上面差不多，没什么要讲的，刚开启时没有待闭环检测关键帧，基本没什么操作，接收到关键帧后就要进行一系列处理，具体步骤就放在<a target="_blank" rel="noopener" href="https://www.jzhblog.top/2023/03/31/ORBSLAM3-NOTE-6/">LoopClosing.cc</a>中了</p>
<hr />
<h4 id="设置线程间的指针"><a class="markdownIt-Anchor" href="#设置线程间的指针"></a> 设置线程间的指针</h4>
<pre><code>mpTracker-&gt;SetLocalMapper(mpLocalMapper);
mpTracker-&gt;SetLoopClosing(mpLoopCloser);

mpLocalMapper-&gt;SetTracker(mpTracker);
mpLocalMapper-&gt;SetLoopCloser(mpLoopCloser);

mpLoopCloser-&gt;SetTracker(mpTracker);
mpLoopCloser-&gt;SetLocalMapper(mpLocalMapper);
</code></pre>
<p>这里是为了不同对象之间能相互调用其他对象的成员变量和函数。</p>
<hr />
<h4 id="创建并开启显示线程"><a class="markdownIt-Anchor" href="#创建并开启显示线程"></a> 创建并开启显示线程</h4>
<pre><code>if(bUseViewer)
//if(false) // TODO
&#123;
    mpViewer = new Viewer(this, mpFrameDrawer,mpMapDrawer,mpTracker,strSettingsFile,settings_);
    mptViewer = new thread(&amp;Viewer::Run, mpViewer);
    mpTracker-&gt;SetViewer(mpViewer);
    mpLoopCloser-&gt;mpViewer = mpViewer;
    mpViewer-&gt;both = mpFrameDrawer-&gt;both;
&#125;
</code></pre>
<p>首先初始化成员变量mpViewer，调用Viewer的构造函数，把传过去的参数赋值给对应变量，有些变量是通过settings_中的Viewer相关的参数赋值的。Viewer线程主要是调用MapDrawer和FrameDrawer画图，代码量多，但实际上又不是很重要，等有时间回头再看吧。</p>
<p>System类对象的初始化基本就完成了。</p>
<hr />
<h3 id="systemtrackmonocular"><a class="markdownIt-Anchor" href="#systemtrackmonocular"></a> System::TrackMonocular()</h3>
<p>这个函数首先把传来的im图像信息深拷贝一份，然后调用函数GrabImageMonocular()</p>
<pre><code>Sophus::SE3f Tcw = mpTracker-&gt;GrabImageMonocular(imToFeed,timestamp,filename);
</code></pre>
<p>传入的参数就是拷贝的图像，时间戳和文件名(为空)。具体见<a target="_blank" rel="noopener" href="https://www.jzhblog.top/2023/03/28/ORBSLAM3_NOTE_3/">Tracking.cc</a></p>
<p>待更新。</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://example.com/2023/03/27/ORBSLAM3_NOTE_1/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Hexo">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2023/03/27/ORBSLAM3_NOTE_1/" itemprop="url">ORBSLAM3 Preview</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2023-03-27T19:05:31+08:00">
                2023-03-27
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="orbslam3学习笔记1"><a class="markdownIt-Anchor" href="#orbslam3学习笔记1"></a> ORBSLAM3学习笔记(1)</h1>
<p>最近开始阅读orbslam3的源码，想一边学习一边写博客记录，以便以后回顾总结，目前slam方面的基础一般，读源码时可能遇到的问题较多，希望能够坚持读下去。ps:源码用的是计算机视觉life的注释版本</p>
<hr />
<h2 id="一-框架结构"><a class="markdownIt-Anchor" href="#一-框架结构"></a> 一、框架结构</h2>
<p>orbslam3的阅读时，我们主要看的是Examples，include，src目录下的文件。include，src目录下主要就是头文件和库函数，下面具体看一下Examples目录。</p>
<p><strong>Examples目录</strong><br />
examples目录下包含了几种传感器的简单案例，也支持ros系统。案例使用的是KITTI,EuRoC,和TUM数据集，文件夹中包含了对应的标定文件，即.yaml文件，目录中还有包含真实传感器的标定文件。<br />
除了这些settings文件，该框架的各种传感器的程序入口也在该目录下。比如我现在看的单目相机，因为我想基于ros运行orbslam3，它的程序入口就是ROS/src目录下的ros_mono.cc文件。马上源码的阅读也会从这个文件开始。</p>
<hr />
<h2 id="二-源码阅读笔记"><a class="markdownIt-Anchor" href="#二-源码阅读笔记"></a> 二、源码阅读笔记</h2>
<h3 id="main函数"><a class="markdownIt-Anchor" href="#main函数"></a> main函数</h3>
<p>main函数在ROS/src目录下的ros_mono.cc文件，整体代码量不多，我就先放在下面了。</p>
<pre><code>int main(int argc, char **argv)
&#123;
    ros::init(argc, argv, &quot;Mono&quot;);
    ros::start();

    if(argc != 3)
    &#123;
        cerr &lt;&lt; endl &lt;&lt; &quot;Usage: rosrun ORB_SLAM3 Mono path_to_vocabulary path_to_settings&quot; &lt;&lt; endl;        
        ros::shutdown();
        return 1;
    &#125;    

    // Create SLAM system. It initializes all system threads and gets ready to process frames.
    ORB_SLAM3::System SLAM(argv[1],argv[2],ORB_SLAM3::System::MONOCULAR,true);

    ImageGrabber igb(&amp;SLAM);

    ros::NodeHandle nodeHandler;
    ros::Subscriber sub = nodeHandler.subscribe(&quot;/camera/image_raw&quot;, 1, &amp;ImageGrabber::GrabImage,&amp;igb);

    ros::spin();

    // Stop all threads
    SLAM.Shutdown();

    // Save camera trajectory
    SLAM.SaveKeyFrameTrajectoryTUM(&quot;KeyFrameTrajectory.txt&quot;);

    ros::shutdown();

    return 0;
&#125;
</code></pre>
<p><strong>先解释一下main函数的运行流程</strong></p>
<pre><code>ros::init(argc, argv, &quot;Mono&quot;);
ros::start();
</code></pre>
<p>这两句用来启动ros结点，之后的if判断是否输入两个参数，这两个参数分别是词袋文件和标定文件的路径。</p>
<pre><code>ORB_SLAM3::System SLAM(argv[1],argv[2],ORB_SLAM3::System::MONOCULAR,true);
</code></pre>
<p>这句是初始化一个slam系统，初始化包括定位、回环、查看线程。 首先会根据输入选择rgbd、mono等容器，然后初始化启动定位、关闭定位、换地图、reset地图等。ORB_SLAM3::System类在System.h中,具体实现在System.cc中，故具体初始化流程在<a target="_blank" rel="noopener" href="https://www.jzhblog.top/2023/03/27/ORBSLAM3_NOTE_2/">System.cc</a>中会详细说明。</p>
<p>初始化完成，创建ImageGrabber对象，在回调函数中调用ImageGrabber类的函数GrabImage</p>
<pre><code>void ImageGrabber::GrabImage(const sensor_msgs::ImageConstPtr&amp; msg)
&#123;
    // Copy the ros image message to cv::Mat.
    cv_bridge::CvImageConstPtr cv_ptr;
    try
    &#123;
        cv_ptr = cv_bridge::toCvShare(msg);
    &#125;
    catch (cv_bridge::Exception&amp; e)
    &#123;
        ROS_ERROR(&quot;cv_bridge exception: %s&quot;, e.what());
        return;
    &#125;

    mpSLAM-&gt;TrackMonocular(cv_ptr-&gt;image,cv_ptr-&gt;header.stamp.toSec());
&#125;
</code></pre>
<p>ros结点接收发布方传来的图像，转换为一个 CvImage 对象，并将其赋值给 cv_ptr。调用mpSLAM的TrackMonocular函数时，作为参数传入，第一个是图像信息，第二个是时间戳。TrackMonocular()就放在<a target="_blank" rel="noopener" href="https://www.jzhblog.top/2023/03/27/ORBSLAM3_NOTE_2/">System.cc</a>中讲了。</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
  </section>

  
  <nav class="pagination">
    <a class="extend prev" rel="prev" href="/">&lt;</a><a class="page-number" href="/">1</a><span class="page-number current">2</span>
  </nav>


          </div>
          


          

        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    
    <div class="sidebar-inner">

      

      

      <section class="site-overview-wrap sidebar-panel sidebar-panel-active">
        <div class="site-overview">
          <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
            
              <p class="site-author-name" itemprop="name"></p>
              <p class="site-description motion-element" itemprop="description"></p>
          </div>

          <nav class="site-state motion-element">

            
              <div class="site-state-item site-state-posts">
              
                <a href="/archives/%7C%7C%20archive">
              
                  <span class="site-state-item-count">13</span>
                  <span class="site-state-item-name">posts</span>
                </a>
              </div>
            

            

            
              
              
              <div class="site-state-item site-state-tags">
                <a href="/tags/index.html">
                  <span class="site-state-item-count">2</span>
                  <span class="site-state-item-name">tags</span>
                </a>
              </div>
            

          </nav>

          

          

          
          

          
          

          

        </div>
      </section>

      

      

    </div>
  </aside>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright">&copy; <span itemprop="copyrightYear">2023</span>
  <span class="with-love">
    <i class="fa fa-user"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">John Doe</span>

  
</div>


  <div class="powered-by">Powered by <a class="theme-link" target="_blank" href="https://hexo.io">Hexo</a></div>



  <span class="post-meta-divider">|</span>



  <div class="theme-info">Theme &mdash; <a class="theme-link" target="_blank" href="https://github.com/iissnan/hexo-theme-next">NexT.Mist</a> v5.1.4</div>




        







        
      </div>
    </footer>

    
      <div class="back-to-top">
        <i class="fa fa-arrow-up"></i>
        
      </div>
    

    

  </div>

  

<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>









  












  
  
    <script type="text/javascript" src="/lib/jquery/index.js?v=2.1.3"></script>
  

  
  
    <script type="text/javascript" src="/lib/fastclick/lib/fastclick.min.js?v=1.0.6"></script>
  

  
  
    <script type="text/javascript" src="/lib/jquery_lazyload/jquery.lazyload.js?v=1.9.7"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/fancybox/source/jquery.fancybox.pack.js?v=2.1.5"></script>
  


  


  <script type="text/javascript" src="/js/src/utils.js?v=5.1.4"></script>

  <script type="text/javascript" src="/js/src/motion.js?v=5.1.4"></script>



  
  

  

  


  <script type="text/javascript" src="/js/src/bootstrap.js?v=5.1.4"></script>



  


  




	





  





  












  





  

  

  

  
  

  
  
    <script type="text/x-mathjax-config">
      MathJax.Hub.Config({
        tex2jax: {
          inlineMath: [ ['$','$'], ["\\(","\\)"]  ],
          processEscapes: true,
          skipTags: ['script', 'noscript', 'style', 'textarea', 'pre', 'code']
        }
      });
    </script>

    <script type="text/x-mathjax-config">
      MathJax.Hub.Queue(function() {
        var all = MathJax.Hub.getAllJax(), i;
        for (i=0; i < all.length; i += 1) {
          all[i].SourceElement().parentNode.className += ' has-jax';
        }
      });
    </script>
    <script type="text/javascript" src="//cdn.bootcss.com/mathjax/2.7.1/latest.js?config=TeX-AMS-MML_HTMLorMML"></script>
  


  

  

</body>
</html>
